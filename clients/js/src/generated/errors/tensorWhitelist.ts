/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

export const enum TensorWhitelistProgramErrorCode {
  /** BadCosigner: passed in cosigner doesnt have the rights to do this */
  BAD_COSIGNER = 0x1770, // 6000
  /** MissingVerification: missing all 3 verification methods: at least one must be present */
  MISSING_VERIFICATION = 0x1771, // 6001
  /** MissingName: missing name */
  MISSING_NAME = 0x1772, // 6002
  /** BadWhitelist: bad whitelist */
  BAD_WHITELIST = 0x1773, // 6003
  /** ProofTooLong: proof provided exceeds the limit of 32 hashes */
  PROOF_TOO_LONG = 0x1774, // 6004
  /** BadOwner: passed in owner doesnt have the rights to do this */
  BAD_OWNER = 0x1775, // 6005
  /** FailedVocVerification: failed voc verification */
  FAILED_VOC_VERIFICATION = 0x1776, // 6006
  /** FailedFvcVerification: failed fvc verification */
  FAILED_FVC_VERIFICATION = 0x1777, // 6007
  /** FailedMerkleProofVerification: failed merkle proof verification */
  FAILED_MERKLE_PROOF_VERIFICATION = 0x1778, // 6008
  /** NoConditions: no whitelist conditions provided */
  NO_CONDITIONS = 0x1779, // 6009
  /** InvalidAuthority: invalid authority */
  INVALID_AUTHORITY = 0x177a, // 6010
  /** NotMerkleRoot: condition at index not a merkle root */
  NOT_MERKLE_ROOT = 0x177b, // 6011
  /** InvalidWhitelistIndex: invalid whitelist index */
  INVALID_WHITELIST_INDEX = 0x177c, // 6012
  /** TooManyConditions: too many conditions */
  TOO_MANY_CONDITIONS = 0x177d, // 6013
  /** EmptyConditions: cannot have empty conditions */
  EMPTY_CONDITIONS = 0x177e, // 6014
  /** TooManyMerkleProofs: too many merkle proofs */
  TOO_MANY_MERKLE_PROOFS = 0x177f, // 6015
  /** WhitelistIsFrozen: whitelist is frozen */
  WHITELIST_IS_FROZEN = 0x1780, // 6016
}

export class TensorWhitelistProgramError extends Error {
  override readonly name = 'TensorWhitelistProgramError';

  readonly code: TensorWhitelistProgramErrorCode;

  readonly cause: Error | undefined;

  constructor(
    code: TensorWhitelistProgramErrorCode,
    name: string,
    message: string,
    cause?: Error
  ) {
    super(`${name} (${code}): ${message}`);
    this.code = code;
    this.cause = cause;
  }
}

let tensorWhitelistProgramErrorCodeMap:
  | Record<TensorWhitelistProgramErrorCode, [string, string]>
  | undefined;
if (__DEV__) {
  tensorWhitelistProgramErrorCodeMap = {
    [TensorWhitelistProgramErrorCode.BAD_COSIGNER]: [
      'BadCosigner',
      `passed in cosigner doesnt have the rights to do this`,
    ],
    [TensorWhitelistProgramErrorCode.MISSING_VERIFICATION]: [
      'MissingVerification',
      `missing all 3 verification methods: at least one must be present`,
    ],
    [TensorWhitelistProgramErrorCode.MISSING_NAME]: [
      'MissingName',
      `missing name`,
    ],
    [TensorWhitelistProgramErrorCode.BAD_WHITELIST]: [
      'BadWhitelist',
      `bad whitelist`,
    ],
    [TensorWhitelistProgramErrorCode.PROOF_TOO_LONG]: [
      'ProofTooLong',
      `proof provided exceeds the limit of 32 hashes`,
    ],
    [TensorWhitelistProgramErrorCode.BAD_OWNER]: [
      'BadOwner',
      `passed in owner doesnt have the rights to do this`,
    ],
    [TensorWhitelistProgramErrorCode.FAILED_VOC_VERIFICATION]: [
      'FailedVocVerification',
      `failed voc verification`,
    ],
    [TensorWhitelistProgramErrorCode.FAILED_FVC_VERIFICATION]: [
      'FailedFvcVerification',
      `failed fvc verification`,
    ],
    [TensorWhitelistProgramErrorCode.FAILED_MERKLE_PROOF_VERIFICATION]: [
      'FailedMerkleProofVerification',
      `failed merkle proof verification`,
    ],
    [TensorWhitelistProgramErrorCode.NO_CONDITIONS]: [
      'NoConditions',
      `no whitelist conditions provided`,
    ],
    [TensorWhitelistProgramErrorCode.INVALID_AUTHORITY]: [
      'InvalidAuthority',
      `invalid authority`,
    ],
    [TensorWhitelistProgramErrorCode.NOT_MERKLE_ROOT]: [
      'NotMerkleRoot',
      `condition at index not a merkle root`,
    ],
    [TensorWhitelistProgramErrorCode.INVALID_WHITELIST_INDEX]: [
      'InvalidWhitelistIndex',
      `invalid whitelist index`,
    ],
    [TensorWhitelistProgramErrorCode.TOO_MANY_CONDITIONS]: [
      'TooManyConditions',
      `too many conditions`,
    ],
    [TensorWhitelistProgramErrorCode.EMPTY_CONDITIONS]: [
      'EmptyConditions',
      `cannot have empty conditions`,
    ],
    [TensorWhitelistProgramErrorCode.TOO_MANY_MERKLE_PROOFS]: [
      'TooManyMerkleProofs',
      `too many merkle proofs`,
    ],
    [TensorWhitelistProgramErrorCode.WHITELIST_IS_FROZEN]: [
      'WhitelistIsFrozen',
      `whitelist is frozen`,
    ],
  };
}

export function getTensorWhitelistProgramErrorFromCode(
  code: TensorWhitelistProgramErrorCode,
  cause?: Error
): TensorWhitelistProgramError {
  if (__DEV__) {
    return new TensorWhitelistProgramError(
      code,
      ...(
        tensorWhitelistProgramErrorCodeMap as Record<
          TensorWhitelistProgramErrorCode,
          [string, string]
        >
      )[code],
      cause
    );
  }

  return new TensorWhitelistProgramError(
    code,
    'Unknown',
    'Error message not available in production bundles. Compile with __DEV__ set to true to see more information.',
    cause
  );
}
